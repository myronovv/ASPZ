2.1
Напишіть програму для визначення моменту, коли time_t
закінчиться. Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

![image](https://github.com/user-attachments/assets/2ed27e8b-69aa-4eed-9bf9-c83753555e9d)

Програма може вивести різний вміст залежно від бітності системи 
я перевірив на двох можливих системах і вот що вийшло 

![image](https://github.com/user-attachments/assets/1015971a-0975-491d-acb4-7be6787009d8)

64 бітна система

![image](https://github.com/user-attachments/assets/3d91c46f-4b92-451d-b6a0-8f005ec7a5e9)

32 

2.2
Розгляньте сегменти у виконуваному файлі……
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.

![image](https://github.com/user-attachments/assets/67ae1815-6d03-461a-a728-78dfec915bfc)

Запуск size

![image](https://github.com/user-attachments/assets/335ac99d-0f77-4937-96e8-fac1684f628c)

2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.

![image](https://github.com/user-attachments/assets/560818ec-bb0c-47cb-a468-bab980cc8af2)

Збільшилось bss бо масив неініціалізований
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.

![image](https://github.com/user-attachments/assets/1285e0f9-0256-4fc3-8f30-26f2f9982af4)

Після ініціалізації масиву bss зменшилось а data наоборот збільшилась

Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?

![image](https://github.com/user-attachments/assets/571a034e-2b93-4938-ac86-f5430a2b9ef8)

![image](https://github.com/user-attachments/assets/8aaeb3a5-d0ac-4c9a-8dd6-4e6faacd084b)

Бачимо , що дата збільшилась тому , що а2 статичний і він одразу попадає в дату 
Якщо масив неініціалізований він попадає в бсс , а якщо ініціалізований то в дату

2.3
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include &lt;stdio.h&gt;
int main() {
int i;
printf(&quot;The stack top is near %p\n&quot;, &amp;i);
return 0;
}
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

![image](https://github.com/user-attachments/assets/37903af0-514c-4cdb-85d5-27d106b6f4b8)

При запуску тестової програми 

![image](https://github.com/user-attachments/assets/c90d97a3-c122-4814-99ad-a92ae15de739)

![image](https://github.com/user-attachments/assets/03e0ca3f-1c9f-4f48-a9a1-175e28c1f15d)

З’імітуєм збільшення стеку додавши 
char large_array[1024 * 1024];
printf("New stack top: %p\n", &large_array);
і вивід буде :

![image](https://github.com/user-attachments/assets/a7305b4f-4fdc-42d3-af47-65e5178f3f82)

2.4
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви
можете:
● Автоматично за допомогою утиліти gstack.
● Вручну за допомогою налагоджувача GDB.
Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання
(Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути
pstack). Якщо gstack не працює, використовуйте другий метод – через
GDB, як показано нижче.

![image](https://github.com/user-attachments/assets/c5b9708f-72ed-495a-a00a-420fb8128cdc)

При виклику команди 
sudo gdb -p 4363 (процес інший бо заново запускав)

![image](https://github.com/user-attachments/assets/9c6159ed-55ce-4cf7-8346-7251d372902b)

2.5
Відомо, що при виклику процедур і поверненні з них процесор
використовує стек . Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.

Без лічильника команд (IP) обійтися не можна, бо він вказує, яку команду виконувати наступною. Стек лише зберігає адресу куди потрібно повернутися після виконання функції, але не показує, яку команду виконувати далі.
Приклад:
Уявімо таку програму

![image](https://github.com/user-attachments/assets/dc84e11c-f98a-4863-b260-6ceb0a4b3d4d)

Коли викликається functionB(, процесор зберігає адресу наступної команди після виклику functionA() на стеку
Коли викликається functionA() процесор починає виконувати її
Після завершення functionA() процесор забирає адресу зі стека і повертається до виконання програми після виклику functionA() в functionB()
Але без лічильника команд (IP) процесор не знатиме куди йому йти після functionA() і не зможе продовжити програму

2.6
10. Аналізуйте поведінку динамічних бібліотек під час завантаження.
Як працює код який має динамічну бібліотеку :
1)Пошук бібліотеки
2) Завантаження в пам'ять
3) Розв'язування символів
4) Ініціалізація
5) Використання бібліотеки
6) Звільнення ресурсів
              Переваги :								                              Недоліки :
Бібліотека використовується кількома програмами     Час завантаження не завжди такий як хотілось би 
Оновлення бібліотеки без перекомпіляції програми    Оновлення бібліотеки може порушити сумісність
Можливість завантажувати нові модулі під час             Небажані зміни в бібліотеці можуть створити  
виконання                                                                                 вразливості
Вот на прикладі цієї програми та динамічної бібліотеки яку я створив для цього :

![image](https://github.com/user-attachments/assets/becf14f1-c0ff-47a9-a4c3-66415a01c11b)

![image](https://github.com/user-attachments/assets/d3fc85ba-eddb-45f7-99eb-3dbbc28ccc60)

Аналіз завантаження бібліотеки виглядає так :

![image](https://github.com/user-attachments/assets/5bf3bf2b-e2aa-45b1-b87c-d92d336c6f67)


