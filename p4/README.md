
Завдання 4.1
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?
 
У Linux на x86_64 використовуються лише 48 бітів для адресації пам’яті 
Тоді виходить максимум 2^48 = 256 тб 
Завдання 4.2
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
Якщо у малок передати від’ємний аргумент то можуть бути небезпечні наслідки бо відбудеться неявне перетворення і від’ємний аргумент перетвориться у велике позитивне число 
Завдання 4.3
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.
При малок(0) він може повернути null , або вказівник який можна передати у free()
 
Програма викликає malloc(0)
Далі програма перевіряє результат виклику:
Якщо повернено NULL, вона просто виводить це.
Якщо повернено ненульовий вказівник — виводить його та викликає free(ptr)
У будь-якому випадку програма завершується без помилок



Завдання 4.4
Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
після free(ptr) не скидається ptr = NULL, отже перевірка if (!ptr) більше неефективна.

Завдання 4.5
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.
Поверне null , але не звільнить пам’ять
 
Завдання 4.6
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.
Якщо realloc(NULL, size) то це як malloc(size)
Якщо realloc(ptr, 0) це як free(ptr) і повернеться null 
 
Завдання 4.7
Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));
 
10. Дослідіть розподіл пам’яті в структурі heap Linux.
ltrace	показує, як malloc/realloc/free викликаються
strace	показує системні виклики (brk, mmap)
gdb	дебаг heap-даних вручну
valgrind	перевірка витоків пам’яті
можна подивитись heap через /proc
наприклад :
cat /proc/$$/maps | grep heap
 
Heap динамічно зростає і зменшується під керуванням malloc/free.

Linux використовує brk/sbrk для малих блоків і mmap — для великих.
