
Завдання 9.1

Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.

![image](https://github.com/user-attachments/assets/bd0816ff-f83d-4fe2-9287-4a08da641ffa)


Спочатку програма отримує ім’я поточного користувача за допомогою getlogin(). Потім відкриває вхідний потік на читання результатів команди getent passwd через popen(). 
Зчитує дані рядок за рядком за допомогою fgets(), розбиває кожен рядок на поля за роздільником : через strtok(), 
вибирає ім’я користувача та UID, перевіряє, чи UID більший або рівний 1000 (тобто звичайний користувач) і чи ім’я не збігається з поточним користувачем. 
Якщо умови виконуються — виводить такого користувача

Завдання 9.2

Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
(Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)
![image](https://github.com/user-attachments/assets/78cbf6b1-0938-48d7-a780-acce42da627a)

Завдання 9.3

Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?

![image](https://github.com/user-attachments/assets/1b59737c-5692-439a-bb70-8333e47a9b94)


Спочатку програма створює файл від імені звичайного користувача за допомогою функції fopen(). 
Далі вона копіює цей файл до домашнього каталогу за допомогою команди sudo cp, яка виконується через system().
Після цього програма намагається змінити цей файл відкриваючи його в режимі (append) за допомогою fopen().
Якщо зміни неможливі то програма виведе помилку. Потім програма спробує видалити файл за допомогою remove(). 
Після завершення програма виведе повідомлення про успішність.


Завдання 9.4

Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена.
Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

![image](https://github.com/user-attachments/assets/e369ba91-3e8c-48a6-a307-e18ab28bbd17)


Завдання 9.5

Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.

![image](https://github.com/user-attachments/assets/5fcc8013-0560-43ce-b278-9b649a01f1d6)


Спочатку програма створює файл через fopen(), потім змінює власника і права через system() із sudo. Далі вона перевіряє доступ до читання ("r") і допису ("a"), і виводить результат

Завдання 9.6

Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc.
Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.

![image](https://github.com/user-attachments/assets/7ecdcad7-56bc-4e8b-a74d-807347b70e8f)


Програма виконує команди ls -l через system() для трьох каталогів.
Потім перебирає три файли та за допомогою access() виводить, чи дозволено читання, запис і виконання

10. Визначте, які приховані механізми можуть дати доступ до закритого ресурсу без зміни прав доступу.

SetUID-бінарні файли
Права доступу через групи
Access Control Lists (ACL)
Кеш або копії в тимчасових місцях
Використання сервісів або daemon'ів

